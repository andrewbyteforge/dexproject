# Intelligence Module - Comprehensive Guide

The intelligence module is the brain of the paper trading bot, orchestrating all trading decisions through a sophisticated multi-level intelligence system (1-10). This module has been reorganized into a logical folder structure for better maintainability and scalability.

---

## üìÅ Folder Structure

```
intelligence/
‚îú‚îÄ‚îÄ config/              # Intelligence level configurations
‚îÇ   ‚îî‚îÄ‚îÄ intel_config.py
‚îú‚îÄ‚îÄ core/                # Core base classes and main orchestrator
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îî‚îÄ‚îÄ intel_slider.py
‚îú‚îÄ‚îÄ strategies/          # Trading strategies and decision logic
‚îÇ   ‚îú‚îÄ‚îÄ decision_maker.py
‚îÇ   ‚îî‚îÄ‚îÄ arbitrage_engine.py
‚îú‚îÄ‚îÄ data/                # Data collection and history tracking
‚îÇ   ‚îú‚îÄ‚îÄ price_history.py
‚îÇ   ‚îî‚îÄ‚îÄ ml_features.py
‚îú‚îÄ‚îÄ dex/                 # DEX integrations and price comparison
‚îÇ   ‚îú‚îÄ‚îÄ dex_integrations.py
‚îÇ   ‚îú‚îÄ‚îÄ dex_price_comparator.py
‚îÇ   ‚îî‚îÄ‚îÄ protocols/       # Protocol-specific implementations
‚îÇ       ‚îú‚îÄ‚îÄ base.py
‚îÇ       ‚îú‚îÄ‚îÄ constants.py
‚îÇ       ‚îú‚îÄ‚îÄ uniswap_v3.py
‚îÇ       ‚îú‚îÄ‚îÄ sushiswap.py
‚îÇ       ‚îú‚îÄ‚îÄ curve.py
‚îÇ       ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ analyzers/           # Market analysis components (real blockchain data)
‚îÇ   ‚îú‚îÄ‚îÄ base.py
‚îÇ   ‚îú‚îÄ‚îÄ composite_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ constants.py
‚îÇ   ‚îú‚îÄ‚îÄ gas_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ liquidity_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ market_state.py
‚îÇ   ‚îú‚îÄ‚îÄ mev_detector.py
‚îÇ   ‚îú‚îÄ‚îÄ volatility_analyzer.py
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ __init__.py          # Public API exports
‚îî‚îÄ‚îÄ README               # This file
```

---

## üéØ System Architecture

### **Intelligence Levels (1-10)**

The system adapts its behavior based on the intelligence level slider:

| Level | Name | Risk Tolerance | Max Position | Confidence Required | Behavior |
|-------|------|---------------|--------------|---------------------|----------|
| 1 | Ultra Cautious | 20% | 2% | 95% | Maximum safety, misses opportunities |
| 2 | Very Cautious | 25% | 3% | 90% | Very conservative |
| 3 | Cautious | 30% | 5% | 85% | Safety first |
| 4 | Moderately Cautious | 40% | 7% | 75% | Balanced toward safety |
| 5 | Balanced (Default) | 50% | 10% | 70% | Optimal balance |
| 6 | Moderately Aggressive | 60% | 12% | 65% | Balanced toward opportunity |
| 7 | Aggressive | 70% | 15% | 60% | Prioritizes opportunities |
| 8 | Very Aggressive | 80% | 18% | 55% | High risk tolerance |
| 9 | Ultra Aggressive | 90% | 20% | 50% | Maximum aggression |
| 10 | Autonomous AI | 100% | 25% | 45% | Full AI control + ML data collection |

### **Decision Flow**

```
User Request ‚Üí IntelSliderEngine
    ‚Üì
1. Fetch Real Token Price (PriceFeedService)
    ‚Üì
2. Update Price History
    ‚Üì
3. Comprehensive Market Analysis (CompositeMarketAnalyzer)
   - Gas conditions (blockchain RPC)
   - Liquidity depth (Uniswap V3 pools)
   - Volatility (price trends)
   - MEV threats (heuristics)
   - Market state (chaos detection)
    ‚Üì
4. Decision Making (DecisionMaker)
   - Calculate risk score
   - Calculate opportunity score
   - Calculate confidence
   - Determine action (BUY/SKIP/SELL)
   - Calculate position size
   - Set stop loss
   - Choose execution strategy
    ‚Üì
5. Apply Intel Level Adjustments
    ‚Üì
6. Collect ML Features (Level 10 only)
    ‚Üì
7. Return TradingDecision
```

---

## üìÇ Folder Details

### **1. config/** - Intelligence Level Configuration

**Purpose:** Centralized configuration for all 10 intelligence levels.

#### **intel_config.py** (179 lines)
- **IntelLevelConfig dataclass**: Configuration for each intelligence level
  - `level`: Intelligence level (1-10)
  - `name`: Human-readable name
  - `description`: Behavior description
  - `risk_tolerance`: Risk tolerance percentage (0-100)
  - `max_position_percent`: Max position size as % of portfolio
  - `min_confidence_required`: Minimum confidence to trade (0-100)
  - `min_position_usd`: Minimum position size in USD
  - `use_mev_protection`: Whether to use MEV protection
  - `gas_aggressiveness`: Gas strategy (minimal/low/standard/aggressive/ultra_aggressive)
  - `trade_frequency`: Trading frequency (very_low/low/moderate/high/very_high)
  - `decision_speed`: Decision speed (slow/moderate/fast)

- **INTEL_CONFIGS dictionary**: Maps each level (1-10) to its configuration

**Key Characteristics:**
- Level 1: Ultra cautious, 95% confidence required, 2% max position
- Level 5: Balanced default, 70% confidence required, 10% max position
- Level 10: Autonomous AI, 45% confidence required, 25% max position + ML collection

---

### **2. core/** - Core Base Classes and Main Orchestrator

**Purpose:** Foundation classes and the main intelligence engine.

#### **base.py** (524 lines)
**Core data structures and abstract base class:**

- **IntelligenceLevel enum**: Represents the 10 intelligence levels as integers
- **MarketContext dataclass**: Comprehensive market data container
  - Token info (symbol, address, price)
  - Volume and liquidity metrics
  - Network conditions (gas, congestion)
  - MEV threat levels
  - Competition metrics
  - Historical performance
  - Data quality indicators

- **TradingDecision dataclass**: Complete trading decision package
  - Action (BUY/SELL/SKIP)
  - Position sizing (percentage and USD)
  - Stop loss and take profit levels
  - Risk and opportunity scores
  - Confidence level
  - Execution strategy (gas, MEV protection)
  - Reasoning and analysis
  - Timing and processing metrics

- **IntelligenceEngine abstract base class**: Template for all intelligence implementations
  - `analyze(token_address, trade_size_usd) -> TradingDecision`
  - `adjust_for_intel_level(decision) -> TradingDecision`
  - `generate_thought_log(decision, context) -> Dict`

**Key Features:**
- Intel-level adjustments (tightens stops/reduces size for cautious levels)
- Autonomous optimization (Level 10 adaptive behavior)
- Thought log generation (human-readable decision explanations)

#### **intel_slider.py** (673 lines) - MAIN ORCHESTRATOR
**The brain that coordinates all components:**

**Components Managed:**
- `CompositeMarketAnalyzer`: Comprehensive market analysis
- `DecisionMaker`: Trading decision logic
- `MLFeatureCollector`: ML training data collection (Level 10)
- `PriceFeedService`: Real-time token prices
- `DEXPriceComparator`: Multi-DEX price comparison (Phase 2)
- `ArbitrageDetector`: Arbitrage detection (Phase 2)

**Main analyze() Method (16-step process):**
1. Fetch real token price
2. Update price history cache
3. Retrieve existing price history for trends
4. Run comprehensive market analysis
5. Enhance market context with analysis results
6. Calculate risk score
7. Calculate opportunity score
8. Determine action (BUY/SKIP/SELL)
9. Calculate position size
10. Calculate stop loss
11. Convert percentages to USD amounts
12. Enforce minimum position size
13. Determine execution strategy
14. Generate reasoning and identify factors
15. Apply intel-level adjustments
16. Collect ML features (Level 10)

**Supporting Methods:**
- `_update_price_history()`: Maintains last 100 prices per token
- `_enhance_context_with_analysis()`: Integrates analysis data with price history
- `_create_skip_decision()`: Generates safe skip decision on errors
- `update_market_context()`: Stores historical contexts and tracks trends
- `get_ml_training_data()`: Retrieves ML training samples (Level 10)

**Key Features:**
- Configuration overrides from database
- Price history tracking (last 100 prices)
- Market trend analysis
- Volatility tracking
- Complete backward compatibility
- Phase 2 support (DEX comparison, arbitrage detection)

---

### **3. strategies/** - Trading Strategies and Decision Logic

**Purpose:** Trading strategies, decision-making, and arbitrage detection.

#### **decision_maker.py** (888 lines) ‚ö†Ô∏è OVER 800 LINE LIMIT
**The decision-making brain:**

**Core Methods:**
- `calculate_risk_score(context, analysis)`: Weighted risk assessment
  - MEV threats (25%)
  - Volatility (20%)
  - Liquidity depth (15%)
  - Network congestion (15%)
  - Bot competition (15%)
  - Chaos events (10%)

- `calculate_opportunity_score(context, analysis)`: Profit potential evaluation
  - Price trends (30%)
  - Momentum (25%)
  - Volume changes (20%)
  - Liquidity quality (15%)
  - Network conditions (10%)

- `calculate_confidence_score(risk, opportunity, context)`: Overall confidence
  - Combines risk and opportunity
  - Adjusts for data quality
  - Normalizes to 0-100 scale

- `determine_action(context, analysis)`: Action determination (BUY/SKIP/SELL)
  - Checks confidence vs minimum required
  - Verifies risk within tolerance
  - Validates price data
  - Ensures opportunity outweighs risk

- `calculate_position_size(opportunity, risk, volatility)`: Adaptive position sizing
  - Starts with configured maximum
  - Adjusts down based on opportunity-to-risk ratio
  - Reduces for high volatility

- `calculate_stop_loss(risk_score, volatility)`: Stop loss calculation
  - Tighter stops for higher risk
  - Adjusts for volatility

- `determine_execution_strategy(context, analysis)`: Execution strategy selection
  - Gas strategy based on urgency and level
  - MEV protection based on threat level
  - Private relay usage for high MEV risk

**Explanation Methods:**
- `generate_reasoning()`: Human-readable decision explanation
- `identify_risk_factors()`: Top 5 risks detected
- `identify_opportunity_factors()`: Positive signals
- `generate_mitigation_strategies()`: Risk reduction suggestions
- `assess_time_sensitivity()`: Urgency determination

**Helper Methods:**
- `_calculate_momentum_score()`: Momentum based on trends, volume, price movement
- `_assess_liquidity_score()`: Liquidity quality evaluation

**Key Features:**
- Weighted scoring system
- Intel-level aware thresholds
- Comprehensive risk assessment
- Adaptive position sizing
- Detailed reasoning generation

#### **arbitrage_engine.py** (915 lines)
**Unified arbitrage detection system (Phase 2):**

**Features:**
- Simple detection from DEXPriceComparison
- Advanced detection from DEX price dictionary
- Comprehensive cost accounting (gas, slippage)
- MEV risk assessment
- Liquidity-based trade sizing
- Confidence scoring
- Performance tracking

**Data Classes:**
- `ArbitrageOpportunity`: Complete arbitrage opportunity data
  - Buy/sell DEX and prices
  - Expected profit (USD and %)
  - Costs (gas, slippage)
  - Net profit after costs
  - Confidence score
  - Risk factors
  - Liquidity constraints

**Main Methods:**
- `detect_from_comparison()`: Simple detection from price comparison
- `detect_from_prices()`: Advanced detection from DEX price dictionary
- `calculate_costs()`: Comprehensive cost calculation
- `assess_mev_risk()`: MEV threat assessment
- `calculate_optimal_size()`: Liquidity-constrained sizing
- `calculate_confidence()`: Confidence scoring

**Key Features:**
- Multi-DEX price comparison
- Real-time gas cost calculation
- Slippage estimation
- MEV protection recommendations
- Liquidity-aware sizing

---

### **4. data/** - Data Collection and History Tracking

**Purpose:** Historical data tracking and ML feature collection.

#### **price_history.py** (212 lines)
**Time-series price tracking:**

- **PriceHistory dataclass**: Historical price data
  - `token_address`: Token contract address
  - `token_symbol`: Token symbol
  - `prices`: List of recent prices (last 100)
  - `timestamps`: List of timestamps

**Methods:**
- `get_price_change_percent(period_minutes)`: Price change over time period
- `is_trending_up()`: Checks if last 3 prices are increasing
- `is_trending_down()`: Checks if last 3 prices are decreasing
- `get_volatility()`: Calculates coefficient of variation

**Key Features:**
- Automatic memory management (last 100 prices)
- Timezone-aware timestamps
- Trend detection
- Volatility calculation
- Robust error handling

#### **ml_features.py** (364 lines)
**Machine learning infrastructure (Level 10 only):**

**MLFeatureCollector class:**
- Automatically captures 40+ features per decision
- Maintains in-memory cache (max 1000 samples)
- Auto-trims older data

**Captured Features:**
- Price metrics (current, 24h change, volatility, momentum)
- Volume statistics
- Liquidity measurements
- Market characteristics (cap, holders)
- Network conditions (gas, congestion)
- MEV environment
- Competition metrics
- Risk indicators
- Historical performance
- Decision outputs (labels for supervised learning)

**Methods:**
- `collect_features(context, decision)`: Auto-capture on each decision
- `get_training_data()`: Retrieve all collected samples
- `clear_training_data()`: Clear collected data
- `export_training_data(format)`: Export as dict/JSON/CSV
- `get_feature_statistics()`: Sample counts, action distribution, average scores

**Key Features:**
- Transparent auto-collection
- Multiple export formats
- Statistics and insights
- Supervised learning ready

---

### **5. dex/** - DEX Integrations and Price Comparison

**Purpose:** Multi-DEX price comparison and protocol integrations.

#### **dex_price_comparator.py** (584 lines)
**Multi-DEX price comparison orchestrator:**

**DEXPriceComparison dataclass:**
- Token info
- Prices from each DEX
- Best buy/sell prices
- Price spread
- Arbitrage potential
- Liquidity metrics
- Timestamp and metadata

**Main Methods:**
- `compare_prices_async()`: Parallel price queries across DEXs
- `get_best_buy_price()`: Find best buy price
- `get_best_sell_price()`: Find best sell price
- `calculate_arbitrage_potential()`: Detect arbitrage opportunities
- `get_price_spread()`: Calculate spread between best buy/sell

**Key Features:**
- Parallel queries with timeouts
- Automatic failover
- Cache integration
- Comprehensive error handling
- Real-time price comparison

#### **dex_integrations.py** (629 lines)
**DEX integration manager:**

**Manages protocol integrations:**
- UniswapV3DEX
- SushiSwapDEX
- CurveDEX

**DEXPrice dataclass:**
- DEX name
- Token address and symbol
- Price
- Liquidity
- Volume
- Confidence score
- Timestamp

**Key Features:**
- Protocol abstraction
- Standardized price data
- Error handling per DEX
- Cache support

---

### **6. dex/protocols/** - Protocol-Specific Implementations

**Purpose:** Individual DEX protocol integrations.

#### **base.py** (250 lines)
**Abstract base class for all DEX integrations:**

- **BaseDEX abstract class**: Template for DEX implementations
  - `get_price_async()`: Fetch token price
  - `get_liquidity()`: Query liquidity
  - `estimate_slippage()`: Calculate expected slippage
  - `validate_token()`: Validate token address

**Key Features:**
- Common interface for all DEXs
- Async/await support
- Error handling patterns
- Cache integration hooks

#### **constants.py** (100 lines)
**Shared constants for DEX protocols:**

- Uniswap V3 factory address
- Fee tiers (0.01%, 0.05%, 0.3%, 1%)
- Factory ABI
- Pool ABI
- Common token addresses
- Network-specific addresses

#### **uniswap_v3.py** (450 lines)
**Uniswap V3 protocol integration:**

**UniswapV3DEX class:**
- Queries all fee tiers for best price
- Pool liquidity calculations
- Tick data analysis
- Price impact estimation

**Key Methods:**
- `get_price_async()`: Fetch price from V3 pools
- `get_pool_for_pair()`: Find pool for token pair
- `get_liquidity()`: Query pool liquidity
- `calculate_price_impact()`: Estimate price impact

**Key Features:**
- Multi-fee-tier support
- Real blockchain data
- Concentrated liquidity handling
- Tick math calculations

#### **sushiswap.py** (180 lines)
**SushiSwap protocol integration:**

**SushiSwapDEX class:**
- V2-style AMM queries
- Reserves-based pricing
- Constant product formula

**Key Methods:**
- `get_price_async()`: Fetch price from SushiSwap
- `get_reserves()`: Query pair reserves
- `calculate_price()`: Price from reserves

#### **curve.py** (150 lines)
**Curve Finance protocol integration:**

**CurveDEX class:**
- Stableswap queries
- Specialized for stablecoin pairs
- Low slippage calculations

**Key Methods:**
- `get_price_async()`: Fetch price from Curve pools
- `get_virtual_price()`: Query virtual price
- `estimate_swap_output()`: Calculate output amount

---

### **7. analyzers/** - Market Analysis Components

**Purpose:** Real blockchain data analysis using specialized analyzers.

See `analyzers/README` for detailed documentation of this subsystem.

**Key Analyzers:**
- **RealGasAnalyzer**: Network gas conditions from blockchain RPC
- **RealLiquidityAnalyzer**: Uniswap V3 pool liquidity queries
- **RealVolatilityAnalyzer**: Price volatility calculations
- **MEVThreatDetector**: MEV threat detection using heuristics
- **MarketStateAnalyzer**: Overall market conditions and chaos detection
- **CompositeMarketAnalyzer**: Orchestrates all analyzers for comprehensive analysis

**Key Features:**
- Real blockchain data (no mock data)
- Lazy initialization for performance
- Comprehensive error handling
- Structured logging
- Cache integration

---

## üîÑ Integration Points

### **Public API (from `__init__.py`):**

```python
from paper_trading.intelligence import (
    # Base classes
    IntelligenceEngine,
    IntelligenceLevel,
    MarketContext,
    TradingDecision,
    
    # Configuration
    IntelLevelConfig,
    INTEL_CONFIGS,
    
    # Data classes
    PriceHistory,
    
    # Component classes
    DecisionMaker,
    MLFeatureCollector,
    
    # Main engine
    IntelSliderEngine,
)
```

### **Main Entry Point:**

```python
# Initialize engine
engine = IntelSliderEngine(
    intel_level=5,  # Balanced default
    account_id="user_account_id",
    strategy_config=strategy_config_obj,  # Optional DB overrides
    chain_id=8453  # Base mainnet
)

# Make trading decision
decision = await engine.analyze(
    token_address="0x...",
    trade_size_usd=Decimal("1000.00")
)

# Access decision data
if decision.action == "BUY":
    print(f"Position size: ${decision.position_size_usd}")
    print(f"Stop loss: {decision.stop_loss_percent}%")
    print(f"Confidence: {decision.overall_confidence}%")
    print(f"Reasoning: {decision.reasoning}")
```

---

## üéì Key Concepts

### **Composition over Inheritance**
The system uses composition to combine specialized components rather than deep inheritance hierarchies. Each component has a single responsibility.

### **Real Data, No Mocks**
All market data comes from real blockchain queries:
- Gas prices from RPC endpoints
- Liquidity from Uniswap V3 contracts
- Volatility from actual price history
- MEV threats from heuristics based on liquidity

### **Intelligence Level Adaptation**
Every decision is adapted based on the intelligence level:
- Risk tolerance affects confidence thresholds
- Position sizing scales with aggressiveness
- Stop losses tighten for cautious levels
- MEV protection enabled/disabled by level

### **Comprehensive Analysis**
The CompositeMarketAnalyzer provides 360¬∞ market view:
- Gas conditions (network state)
- Liquidity depth (execution feasibility)
- Volatility (price stability)
- MEV threats (security risks)
- Market state (chaos detection)

### **Phase 2 Features (Optional)**
When enabled, adds:
- Multi-DEX price comparison
- Arbitrage detection
- Optimal price finding across DEXs

---

## üìä File Line Counts

| File | Lines | Status |
|------|-------|--------|
| config/intel_config.py | 179 | ‚úÖ Under limit |
| core/base.py | 524 | ‚úÖ Under limit |
| core/intel_slider.py | 673 | ‚úÖ Under limit |
| strategies/decision_maker.py | 888 | ‚ö†Ô∏è **OVER LIMIT** (88 lines over) |
| strategies/arbitrage_engine.py | 915 | ‚ö†Ô∏è **OVER LIMIT** (115 lines over) |
| data/price_history.py | 212 | ‚úÖ Under limit |
| data/ml_features.py | 364 | ‚úÖ Under limit |
| dex/dex_price_comparator.py | 584 | ‚úÖ Under limit |
| dex/dex_integrations.py | 629 | ‚úÖ Under limit |

**Note:** Two files exceed the 800-line limit and should be considered for refactoring in future iterations.

---

## üöÄ Performance Optimizations

### **Lazy Initialization**
Components initialize on first use rather than at startup:
- Web3 clients connect when needed
- Analyzers initialize when first called
- Price feeds activate on demand

### **Caching Strategy**
Multiple cache layers reduce redundant queries:
- Price history cache (in-memory)
- DEX price cache (Redis)
- Pool data cache (Redis)
- Analysis results cache (short TTL)

### **Parallel Queries**
Multi-DEX price comparison runs in parallel:
- asyncio for concurrent DEX queries
- Timeout protection per query
- Automatic failover on errors

### **Memory Management**
Automatic data trimming prevents memory bloat:
- Price history limited to 100 points per token
- ML features limited to 1000 samples
- Market history rotates old data

---

## üîê Error Handling Strategy

### **Graceful Degradation**
System continues functioning even when components fail:
- Missing gas data ‚Üí Uses defaults
- DEX query timeout ‚Üí Uses cached price
- Analysis error ‚Üí Safe SKIP decision

### **Comprehensive Logging**
Structured logging at every level:
- DEBUG: Detailed execution flow
- INFO: Key decisions and data
- WARNING: Degraded performance
- ERROR: Failures with stack traces

### **Safe Defaults**
When data is unavailable, use safe conservative values:
- High risk scores when uncertain
- Low opportunity scores when data missing
- Skip decisions when confidence low
- Minimum position sizes when volatile

---

## üìà Future Enhancements

### **Planned Improvements**
1. Split decision_maker.py (currently 888 lines) into sub-modules
2. Split arbitrage_engine.py (currently 915 lines) into components
3. Add backtesting support using historical data
4. Implement ML models trained on Level 10 data
5. Add TWAP/VWAP exit strategies
6. Expand to additional DEXs (Balancer, 1inch)
7. Add cross-chain arbitrage detection
8. Implement portfolio-level risk management

### **Phase 7 Features**
- Production deployment optimization
- Comprehensive monitoring (Prometheus/Grafana)
- Advanced analytics dashboard
- Mobile interface for monitoring

---

## üõ†Ô∏è Development Guidelines

### **Adding New Intelligence Levels**
1. Add configuration to `INTEL_CONFIGS` in `config/intel_config.py`
2. Update level validation in `core/base.py`
3. Test decision behavior across all levels

### **Adding New Analyzers**
1. Create analyzer class in `analyzers/` inheriting from `BaseAnalyzer`
2. Add to `CompositeMarketAnalyzer` initialization
3. Update comprehensive analysis integration

### **Adding New DEX Protocols**
1. Create protocol class in `dex/protocols/` inheriting from `BaseDEX`
2. Add to `dex_integrations.py` manager
3. Update `dex_price_comparator.py` to include new protocol

### **Code Standards**
- Maximum 800 lines per file (when practical)
- Comprehensive error handling in all methods
- Structured logging from start to finish
- Full docstrings for all functions/classes
- Type hints everywhere
- Pylance and flake8 compliance

---

## üéØ Quick Reference

### **Common Tasks**

**Change Intelligence Level:**
```python
engine.intel_level = 7  # Set to aggressive
engine.config = INTEL_CONFIGS[7]  # Update config
```

**Override Configuration:**
```python
engine = IntelSliderEngine(
    intel_level=5,
    strategy_config=strategy_config  # DB overrides
)
```

**Get ML Training Data:**
```python
if engine.intel_level == 10:
    data = engine.get_ml_training_data()
    # Export as CSV
    csv_data = engine.ml_collector.export_training_data('csv')
```

**Access Price History:**
```python
history = engine.price_history_cache.get(token_address)
if history:
    volatility = history.get_volatility()
    is_bullish = history.is_trending_up()
```

**Check Phase 2 Availability:**
```python
if engine.PHASE_2_AVAILABLE:
    # Use multi-DEX comparison
    comparison = await engine.dex_comparator.compare_prices_async(...)
```

---

## üìû Support

For questions or issues:
1. Check this README for architecture overview
2. Review individual file docstrings for implementation details
3. Examine analyzer README for market analysis specifics
4. Check test files for usage examples

---

**Last Updated:** November 8, 2025  
**Version:** 2.0 (Post-Reorganization)  
**Structure:** Option 1 (Functional Grouping)