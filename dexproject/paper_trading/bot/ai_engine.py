"""
AI Decision Engine for Paper Trading - PTphase2

This module provides rule-based logic that mimics AI decision-making for the paper trading bot.
It analyzes market conditions, determines Fast vs Smart Lane trading, and generates detailed
thought logs for each decision.

Features:
- Market trend analysis (simulated)
- Fast Lane vs Smart Lane decision logic
- Risk assessment
- Detailed reasoning generation
- Buy/sell signal generation

File: dexproject/paper_trading/bot/ai_engine.py
"""

import random
import logging
from typing import Dict, Any, Optional, Tuple, List
from decimal import Decimal
from datetime import datetime, timedelta
from enum import Enum

from paper_trading.models import (
    PaperAIThoughtLog,
    PaperStrategyConfiguration,
    PaperTradingSession,
    PaperPerformanceMetrics
)


logger = logging.getLogger(__name__)


class TradingSignal(Enum):
    """Trading signal types generated by the AI engine."""
    STRONG_BUY = "strong_buy"
    BUY = "buy"
    HOLD = "hold"
    SELL = "sell"
    STRONG_SELL = "strong_sell"


class MarketCondition(Enum):
    """Market condition classifications."""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"
    VOLATILE = "volatile"


class PaperTradingAIEngine:
    """
    AI Decision Engine for paper trading that simulates intelligent market analysis
    and trading decisions using rule-based logic.
    
    This engine analyzes market conditions, determines trading strategies,
    and generates detailed thought logs for transparency.
    """
    
    def __init__(self, session: PaperTradingSession, strategy_config: PaperStrategyConfiguration):
        """
        Initialize the AI engine with trading session and strategy configuration.
        
        Args:
            session: Current paper trading session
            strategy_config: Strategy configuration with thresholds and parameters
        """
        self.session = session
        self.strategy_config = strategy_config
        self.logger = logging.getLogger(f"{__name__}.{session.session_id}")
        
        # Market analysis parameters
        self.fast_lane_threshold = Decimal("2.0")  # 2% price movement triggers Fast Lane
        self.risk_threshold = Decimal("5.0")  # 5% volatility is considered high risk
        self.momentum_window = 5  # Number of ticks to analyze for momentum
        
        # Performance tracking
        self.decision_count = 0
        self.successful_decisions = 0
        self.session_start_time = datetime.now()
        
        logger.info(f"[BOT] AI Engine initialized for session {session.session_id}")
    
    def analyze_market(self, current_price: Decimal, price_history: List[Decimal]) -> Dict[str, Any]:
        """
        Analyze market conditions based on price data.
        
        Args:
            current_price: Current token price
            price_history: Recent price history (list of prices)
            
        Returns:
            Dictionary containing market analysis results
        """
        analysis = {
            "timestamp": datetime.now(),
            "current_price": current_price,
            "price_change_percent": Decimal("0"),
            "volatility": Decimal("0"),
            "trend": "neutral",
            "momentum": Decimal("0"),
            "market_condition": MarketCondition.NEUTRAL,
            "confidence_score": Decimal("50"),  # 0-100 confidence
        }
        
        if not price_history or len(price_history) < 2:
            logger.warning("Insufficient price history for analysis")
            return analysis
        
        # Calculate price change
        previous_price = price_history[-1]
        if previous_price > 0:
            price_change = ((current_price - previous_price) / previous_price) * 100
            analysis["price_change_percent"] = price_change
        
        # Calculate volatility (simplified standard deviation)
        if len(price_history) >= 3:
            avg_price = sum(price_history[-5:]) / len(price_history[-5:])
            variance = sum((p - avg_price) ** 2 for p in price_history[-5:]) / len(price_history[-5:])
            analysis["volatility"] = (variance ** Decimal("0.5") / avg_price * 100) if avg_price > 0 else Decimal("0")
        
        # Determine trend
        if len(price_history) >= 3:
            recent_avg = sum(price_history[-3:]) / 3
            older_avg = sum(price_history[-6:-3]) / 3 if len(price_history) >= 6 else price_history[0]
            
            if recent_avg > older_avg * Decimal("1.01"):  # 1% threshold
                analysis["trend"] = "bullish"
                analysis["market_condition"] = MarketCondition.BULLISH
            elif recent_avg < older_avg * Decimal("0.99"):
                analysis["trend"] = "bearish"
                analysis["market_condition"] = MarketCondition.BEARISH
            else:
                analysis["trend"] = "neutral"
                analysis["market_condition"] = MarketCondition.NEUTRAL
        
        # Calculate momentum (rate of change)
        if len(price_history) >= self.momentum_window:
            momentum_start = price_history[-self.momentum_window]
            if momentum_start > 0:
                analysis["momentum"] = ((current_price - momentum_start) / momentum_start) * 100
        
        # Check for volatile conditions
        if analysis["volatility"] > self.risk_threshold:
            analysis["market_condition"] = MarketCondition.VOLATILE
        
        # Calculate confidence score based on trend strength and volatility
        confidence = Decimal("50")  # Base confidence
        
        # Adjust for trend strength
        if abs(analysis["price_change_percent"]) > 3:
            confidence += Decimal("20")
        elif abs(analysis["price_change_percent"]) > 1:
            confidence += Decimal("10")
        
        # Adjust for volatility (lower confidence in volatile markets)
        if analysis["volatility"] > 5:
            confidence -= Decimal("20")
        elif analysis["volatility"] > 3:
            confidence -= Decimal("10")
        
        # Add momentum bonus
        if abs(analysis["momentum"]) > 5:
            confidence += Decimal("15")
        
        analysis["confidence_score"] = max(Decimal("10"), min(Decimal("90"), confidence))
        
        return analysis
    
    def determine_trading_lane(self, market_analysis: Dict[str, Any]) -> Tuple[str, str]:
        """
        Determine whether to use Fast Lane or Smart Lane based on market conditions.
        
        Args:
            market_analysis: Market analysis results
            
        Returns:
            Tuple of (lane_type, reasoning)
        """
        price_change = abs(market_analysis["price_change_percent"])
        volatility = market_analysis["volatility"]
        confidence = market_analysis["confidence_score"]
        
        # Fast Lane criteria: Significant price movement with clear trend
        if price_change > self.fast_lane_threshold and confidence > 60:
            reasoning = (
                f"Fast Lane triggered: Price movement of {price_change:.2f}% exceeds {self.fast_lane_threshold}% threshold. "
                f"High confidence ({confidence:.0f}%) suggests quick action needed."
            )
            return "FAST", reasoning
        
        # Smart Lane criteria: Complex market conditions requiring analysis
        if volatility > 3 or market_analysis["market_condition"] == MarketCondition.VOLATILE:
            reasoning = (
                f"Smart Lane selected: High volatility ({volatility:.2f}%) requires careful analysis. "
                f"Market condition is {market_analysis['market_condition'].value}. "
                "Comprehensive risk assessment needed before trading."
            )
            return "SMART", reasoning
        
        # Default to Smart Lane for normal conditions
        reasoning = (
            f"Smart Lane selected: Standard market conditions. "
            f"Price change: {price_change:.2f}%, Volatility: {volatility:.2f}%. "
            "Performing full analysis for optimal decision."
        )
        return "SMART", reasoning
    
    def generate_trading_signal(
        self, 
        market_analysis: Dict[str, Any],
        lane_type: str
    ) -> Tuple[TradingSignal, Decimal]:
        """
        Generate trading signal and position size based on analysis.
        
        Args:
            market_analysis: Market analysis results
            lane_type: FAST or SMART lane
            
        Returns:
            Tuple of (signal, position_size_percent)
        """
        condition = market_analysis["market_condition"]
        momentum = market_analysis["momentum"]
        confidence = market_analysis["confidence_score"]
        price_change = market_analysis["price_change_percent"]
        
        # Position sizing based on confidence and lane type
        if lane_type == "FAST":
            base_position = Decimal("15")  # 15% for Fast Lane trades
        else:
            base_position = Decimal("10")  # 10% for Smart Lane trades
        
        # Adjust position size based on confidence
        position_multiplier = confidence / 100
        position_size = base_position * position_multiplier
        
        # Generate signal based on market conditions
        signal = TradingSignal.HOLD
        
        if condition == MarketCondition.BULLISH:
            if momentum > 5 and price_change > 2:
                signal = TradingSignal.STRONG_BUY
                position_size *= Decimal("1.5")  # Increase position for strong signals
            elif momentum > 0:
                signal = TradingSignal.BUY
        
        elif condition == MarketCondition.BEARISH:
            if momentum < -5 and price_change < -2:
                signal = TradingSignal.STRONG_SELL
                position_size *= Decimal("1.5")
            elif momentum < 0:
                signal = TradingSignal.SELL
        
        elif condition == MarketCondition.VOLATILE:
            # Reduce position size in volatile markets
            position_size *= Decimal("0.5")
            
            # Only trade on strong signals in volatile conditions
            if momentum > 3:
                signal = TradingSignal.BUY
            elif momentum < -3:
                signal = TradingSignal.SELL
            else:
                signal = TradingSignal.HOLD
        
        else:  # NEUTRAL
            # Small positions in neutral markets
            position_size *= Decimal("0.7")
            
            if price_change > 1:
                signal = TradingSignal.BUY
            elif price_change < -1:
                signal = TradingSignal.SELL
        
        # Cap position size
        position_size = min(position_size, Decimal("25"))  # Max 25% of portfolio
        
        return signal, position_size
    
    def assess_risk(self, market_analysis: Dict[str, Any], position_size: Decimal) -> Dict[str, Any]:
        """
        Assess risk for the proposed trade.
        
        Args:
            market_analysis: Market analysis results
            position_size: Proposed position size as percentage
            
        Returns:
            Risk assessment dictionary
        """
        volatility = market_analysis["volatility"]
        confidence = market_analysis["confidence_score"]
        
        # Calculate risk score (0-100, higher is riskier)
        risk_score = Decimal("0")
        
        # Volatility contributes to risk
        risk_score += volatility * 10
        
        # Low confidence increases risk
        risk_score += (100 - confidence) / 2
        
        # Large position size increases risk
        risk_score += position_size * 2
        
        # Cap risk score
        risk_score = min(risk_score, Decimal("100"))
        
        # Determine risk level
        if risk_score < 30:
            risk_level = "LOW"
        elif risk_score < 60:
            risk_level = "MEDIUM"
        else:
            risk_level = "HIGH"
        
        # Calculate stop loss and take profit based on risk
        if risk_level == "LOW":
            stop_loss_percent = Decimal("3")
            take_profit_percent = Decimal("5")
        elif risk_level == "MEDIUM":
            stop_loss_percent = Decimal("5")
            take_profit_percent = Decimal("8")
        else:  # HIGH
            stop_loss_percent = Decimal("7")
            take_profit_percent = Decimal("12")
        
        return {
            "risk_score": risk_score,
            "risk_level": risk_level,
            "stop_loss_percent": stop_loss_percent,
            "take_profit_percent": take_profit_percent,
            "max_drawdown_percent": stop_loss_percent * position_size / 100,
            "risk_reward_ratio": take_profit_percent / stop_loss_percent,
        }
    
    def generate_decision(
        self,
        token_address: str,
        token_symbol: str,
        current_price: Decimal,
        price_history: List[Decimal]
    ) -> Dict[str, Any]:
        """
        Generate a complete trading decision with detailed reasoning.
        
        This is the main entry point for the AI engine, coordinating all analysis
        and decision-making components.
        
        Args:
            token_address: Token contract address
            token_symbol: Token symbol
            current_price: Current token price
            price_history: Recent price history
            
        Returns:
            Complete decision dictionary with signal, reasoning, and parameters
        """
        self.decision_count += 1
        decision_start = datetime.now()
        
        logger.info(f"[AI] Generating decision #{self.decision_count} for {token_symbol}")
        
        # Step 1: Market Analysis
        market_analysis = self.analyze_market(current_price, price_history)
        
        # Step 2: Determine Trading Lane
        lane_type, lane_reasoning = self.determine_trading_lane(market_analysis)
        
        # Step 3: Generate Trading Signal
        signal, position_size = self.generate_trading_signal(market_analysis, lane_type)
        
        # Step 4: Risk Assessment
        risk_assessment = self.assess_risk(market_analysis, position_size)
        
        # Step 5: Build complete decision
        decision = {
            "token_address": token_address,
            "token_symbol": token_symbol,
            "timestamp": decision_start,
            "lane_type": lane_type,
            "signal": signal,
            "action": self._signal_to_action(signal),
            "position_size_percent": position_size,
            "current_price": current_price,
            "market_analysis": market_analysis,
            "risk_assessment": risk_assessment,
            "confidence_score": market_analysis["confidence_score"],
            "processing_time_ms": (datetime.now() - decision_start).total_seconds() * 1000,
        }
        
        # Step 6: Generate detailed reasoning
        reasoning = self._generate_reasoning(
            decision, 
            lane_reasoning, 
            market_analysis, 
            risk_assessment
        )
        decision["reasoning"] = reasoning
        
        # Step 7: Log the thought process
        self._log_thought(decision)
        
        logger.info(
            f"[OK] Decision complete: {signal.value} signal for {token_symbol} "
            f"({lane_type} lane, {position_size:.1f}% position)"
        )
        
        return decision
    
    def _signal_to_action(self, signal: TradingSignal) -> str:
        """Convert trading signal to action string."""
        if signal in [TradingSignal.STRONG_BUY, TradingSignal.BUY]:
            return "BUY"
        elif signal in [TradingSignal.STRONG_SELL, TradingSignal.SELL]:
            return "SELL"
        else:
            return "HOLD"
    
    def _generate_reasoning(
        self,
        decision: Dict[str, Any],
        lane_reasoning: str,
        market_analysis: Dict[str, Any],
        risk_assessment: Dict[str, Any]
    ) -> str:
        """
        Generate detailed reasoning for the trading decision.
        
        Args:
            decision: Complete decision dictionary
            lane_reasoning: Reasoning for lane selection
            market_analysis: Market analysis results
            risk_assessment: Risk assessment results
            
        Returns:
            Detailed reasoning string
        """
        signal = decision["signal"]
        action = decision["action"]
        position_size = decision["position_size_percent"]
        
        # Build comprehensive reasoning
        reasoning_parts = [
            f"[DATA] Market Analysis: {market_analysis['market_condition'].value.upper()} conditions detected.",
            f"Price changed {market_analysis['price_change_percent']:.2f}% with {market_analysis['volatility']:.2f}% volatility.",
            f"Momentum indicator: {market_analysis['momentum']:.2f}%, Trend: {market_analysis['trend'].upper()}.",
            "",
            f"🛤️ Strategy Selection: {lane_reasoning}",
            "",
            f"[UP] Trading Signal: {signal.value.upper()} generated with {market_analysis['confidence_score']:.0f}% confidence.",
            f"Action: {action} with {position_size:.1f}% position size.",
            "",
            f"[WARN] Risk Assessment: {risk_assessment['risk_level']} risk (score: {risk_assessment['risk_score']:.0f}/100).",
            f"Stop Loss: -{risk_assessment['stop_loss_percent']:.1f}%, Take Profit: +{risk_assessment['take_profit_percent']:.1f}%.",
            f"Risk/Reward Ratio: 1:{risk_assessment['risk_reward_ratio']:.2f}.",
            f"Maximum portfolio drawdown: {risk_assessment['max_drawdown_percent']:.2f}%.",
        ]
        
        # Add specific reasoning based on action
        if action == "BUY":
            reasoning_parts.append("")
            reasoning_parts.append(
                f"[IDEA] Buy Rationale: {market_analysis['trend'].capitalize()} trend with positive momentum "
                f"({market_analysis['momentum']:.2f}%) suggests upward price movement. "
                f"Entry at ${decision['current_price']:.6f} offers favorable risk/reward."
            )
        elif action == "SELL":
            reasoning_parts.append("")
            reasoning_parts.append(
                f"[IDEA] Sell Rationale: {market_analysis['trend'].capitalize()} trend with negative momentum "
                f"({market_analysis['momentum']:.2f}%) indicates potential downside. "
                f"Exit at ${decision['current_price']:.6f} to protect capital."
            )
        else:  # HOLD
            reasoning_parts.append("")
            reasoning_parts.append(
                f"[IDEA] Hold Rationale: Insufficient signal strength or unclear market direction. "
                f"Waiting for better entry opportunity with higher confidence."
            )
        
        return "\n".join(reasoning_parts)
    
    def _log_thought(self, decision: Dict[str, Any]) -> None:
        """
        Log the AI thought process to the database.
        
        Args:
            decision: Complete decision dictionary with reasoning
        """
        try:
            # Log to console for debugging
            logger.debug(
                f"[THOUGHT] Decision for {decision.get('token_symbol', '?')}: "
                f"{decision.get('action', '?')} with {decision.get('confidence_score', 0):.0f}% confidence"
            )
            
            # Note: PaperAIThoughtLog model creation disabled until model fields are verified
            # This prevents database constraint errors during bot operation
            
        except Exception as e:
            logger.error(f"Failed to log thought: {e}", exc_info=True)

    def update_performance_metrics(self, trade_result: Dict[str, Any]) -> None:
        """
        Update performance metrics based on trade results.
        
        This method tracks trading performance using the PaperPerformanceMetrics model.
        It calculates win rates, P&L, and other key performance indicators.
        
        Args:
            trade_result: Dictionary containing trade outcome information.
                Expected keys:
                - 'profitable': bool - Whether trade was profitable
                - 'pnl_usd': Decimal - Profit/loss in USD
                - 'lane_type': str - 'FAST' or 'SMART' lane
                - 'execution_time_ms': int - Trade execution time
        """
        try:
            # Get the current time for period tracking
            current_time = datetime.now()
            
            # Try to get existing metrics for this session, or create new one
            metrics = PaperPerformanceMetrics.objects.filter(
                session=self.session
            ).order_by('-period_end').first()
            
            # If no metrics exist or current period is old, create new metrics record
            if not metrics or (current_time - metrics.period_end) > timedelta(hours=24):
                logger.info("[METRICS] Creating new performance metrics record")
                metrics = PaperPerformanceMetrics.objects.create(
                    session=self.session,
                    period_start=self.session_start_time,
                    period_end=current_time,
                    # Trade statistics
                    total_trades=0,
                    winning_trades=0,
                    losing_trades=0,
                    win_rate=Decimal("0"),
                    # Financial metrics
                    total_pnl_usd=Decimal("0"),
                    total_pnl_percent=Decimal("0"),
                    avg_win_usd=Decimal("0"),
                    avg_loss_usd=Decimal("0"),
                    largest_win_usd=Decimal("0"),
                    largest_loss_usd=Decimal("0"),
                    # Risk metrics
                    sharpe_ratio=None,
                    max_drawdown_percent=Decimal("0"),
                    profit_factor=None,
                    # Execution metrics
                    avg_execution_time_ms=0,
                    total_gas_fees_usd=Decimal("0"),
                    avg_slippage_percent=Decimal("0"),
                    # Strategy metrics
                    fast_lane_trades=0,
                    smart_lane_trades=0,
                    fast_lane_win_rate=Decimal("0"),
                    smart_lane_win_rate=Decimal("0"),
                )
            
            # Update trade count
            metrics.total_trades += 1
            
            # Extract trade result data
            pnl_usd = trade_result.get("pnl_usd", Decimal("0"))
            is_profitable = trade_result.get("profitable", False)
            lane_type = trade_result.get("lane_type", "SMART")
            execution_time_ms = trade_result.get("execution_time_ms", 0)
            
            # Update winning/losing trades
            if is_profitable:
                metrics.winning_trades += 1
                self.successful_decisions += 1
                
                # Update largest win
                if pnl_usd > metrics.largest_win_usd:
                    metrics.largest_win_usd = pnl_usd
                
                # Update average win (running average)
                if metrics.winning_trades > 0:
                    metrics.avg_win_usd = (
                        (metrics.avg_win_usd * (metrics.winning_trades - 1) + pnl_usd) / 
                        metrics.winning_trades
                    )
            else:
                metrics.losing_trades += 1
                
                # Update largest loss
                if abs(pnl_usd) > abs(metrics.largest_loss_usd):
                    metrics.largest_loss_usd = pnl_usd
                
                # Update average loss (running average)
                if metrics.losing_trades > 0:
                    metrics.avg_loss_usd = (
                        (metrics.avg_loss_usd * (metrics.losing_trades - 1) + pnl_usd) / 
                        metrics.losing_trades
                    )
            
            # Calculate win rate
            if metrics.total_trades > 0:
                metrics.win_rate = (Decimal(metrics.winning_trades) / Decimal(metrics.total_trades)) * 100
            
            # Update total P&L
            metrics.total_pnl_usd += pnl_usd
            
            # Update execution time (running average)
            if metrics.total_trades > 0:
                metrics.avg_execution_time_ms = int(
                    (metrics.avg_execution_time_ms * (metrics.total_trades - 1) + execution_time_ms) / 
                    metrics.total_trades
                )
            
            # Update lane-specific metrics
            if lane_type == "FAST":
                metrics.fast_lane_trades += 1
                if is_profitable and metrics.fast_lane_trades > 0:
                    # Recalculate fast lane win rate
                    fast_wins = int((metrics.fast_lane_win_rate * (metrics.fast_lane_trades - 1) / 100)) + 1
                    metrics.fast_lane_win_rate = (Decimal(fast_wins) / Decimal(metrics.fast_lane_trades)) * 100
            else:  # SMART lane
                metrics.smart_lane_trades += 1
                if is_profitable and metrics.smart_lane_trades > 0:
                    # Recalculate smart lane win rate
                    smart_wins = int((metrics.smart_lane_win_rate * (metrics.smart_lane_trades - 1) / 100)) + 1
                    metrics.smart_lane_win_rate = (Decimal(smart_wins) / Decimal(metrics.smart_lane_trades)) * 100
            
            # Update period end to current time
            metrics.period_end = current_time
            
            # Save updated metrics
            metrics.save()
            
            # Log the performance update
            logger.info(
                f"📊 Performance updated: "
                f"Win rate {metrics.win_rate:.1f}% ({metrics.winning_trades}W/{metrics.losing_trades}L), "
                f"Total P&L: ${metrics.total_pnl_usd:.2f}, "
                f"Trades: {metrics.total_trades}"
            )
            
        except Exception as e:
            logger.error(f"Failed to update performance metrics: {e}", exc_info=True)


# Convenience function for creating AI engine
def create_ai_engine(session: PaperTradingSession) -> PaperTradingAIEngine:
    """
    Create and configure an AI engine for the given trading session.
    
    Args:
        session: Paper trading session
        
    Returns:
        Configured AI engine instance
    """
    # Get the account from the session
    account = session.account
    
    # Get or create strategy configuration
    strategy_config, created = PaperStrategyConfiguration.objects.get_or_create(
        account=account,
        name=f"Strategy_{session.session_id}",
        defaults={
            'is_active': True,
            'trading_mode': 'MODERATE',
            'use_fast_lane': True,
            'use_smart_lane': True,
            'max_position_size_percent': Decimal("25"),
            'stop_loss_percent': Decimal("5"),
            'take_profit_percent': Decimal("10"),
            'max_daily_trades': 50,
            'confidence_threshold': Decimal("40"),
        }
    )
    
    if created:
        logger.info(f"Created new strategy configuration: {strategy_config.name}")
    
    return PaperTradingAIEngine(session, strategy_config)